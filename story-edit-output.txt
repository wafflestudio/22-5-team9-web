This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-01T09:49:04.891Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
api/
  auth.ts
  profile.ts
  search.ts
components/
  feed/
    Stories.tsx
  layout/
    MobileBar.tsx
    MobileHeader.tsx
    NavItem.tsx
    SideBar.tsx
  modals/
    SearchModal.tsx
  shared/
    default-profile.svg
  story/
    Editor/
      ImageProcessor.tsx
      StoryEditor.tsx
    StoryViewer/
      StoryControls.tsx
      StoryProgress.tsx
      StoryUserInfo.tsx
      StoryViewer.tsx
    StoryCreator.tsx
    StoryItem.tsx
    StoryList.tsx
hooks/
  useAuth.ts
  useSearch.ts
  useStories.ts
  useStoryUpload.ts
  useUserInfo.ts
pages/
  LoginPage.tsx
  MainPage.tsx
  StoryPage.tsx
types/
  auth.ts
  search.ts
  story.ts
  user.ts
App.tsx
index.css
main.tsx
vite-env.d.ts

================================================================
Files
================================================================

================
File: api/auth.ts
================
import { myProfile } from './profile';

interface SignupRequest {
  username: string;
  password: string;
  full_name: string;
  email: string;
  phone_number: string;
}

export const signup = async (formData: SignupRequest) => {
  const response = await fetch(
    'https://waffle-instaclone.kro.kr/api/user/signup',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(formData),
    },
  );

  if (!response.ok) {
    const errorData = (await response.json()) as { detail?: string };
    throw new Error(errorData.detail ?? '회원가입에 실패했습니다.');
  }
};

interface SignInResponse {
  access_token: string;
  refresh_token: string;
}

export const signin = async (username: string, password: string) => {
  const response = await fetch(
    'https://waffle-instaclone.kro.kr/api/user/signin',
    {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        username,
        password,
      }),
    },
  );

  if (response.ok) {
    const data = (await response.json()) as SignInResponse;
    localStorage.setItem('access_token', data.access_token);
    localStorage.setItem('refresh_token', data.refresh_token);

    return await myProfile(data.access_token);
  }

  if (response.status === 401) {
    throw new Error('아이디 또는 비밀번호가 일치하지 않습니다.');
  }

  throw new Error('로그인 중 오류가 발생했습니다.');
};

================
File: api/profile.ts
================
import type { UserProfile } from '../types/user';

export const myProfile = async (token: string) => {
  try {
    const response = await fetch(
      'https://waffle-instaclone.kro.kr/api/user/profile',
      {
        headers: {
          Authorization: `Bearer ${token}`,
          accept: 'application/json',
        },
      },
    );

    if (response.ok) {
      const profileData = (await response.json()) as UserProfile;
      return profileData;
    }
    throw new Error('Profile fetch failed');
  } catch (err) {
    console.error('Profile fetch error:', err);
    return null;
  }
};

export async function fetchUserProfile(username: string): Promise<UserProfile> {
  try {
    const response = await fetch(
      `https://waffle-instaclone.kro.kr/api/user/${username}`,
    );
    if (!response.ok) {
      throw new Error('Failed to fetch user data');
    }
    return (await response.json()) as UserProfile;
  } catch (error) {
    console.error('Error fetching user data:', error);
    throw error;
  }
}

type ProfileUpdateData = {
  username?: string;
  introduce?: string;
  profile_image?: File;
};

export const updateProfile = async (
  data: ProfileUpdateData,
): Promise<UserProfile> => {
  const params = new URLSearchParams();

  if (data.username != null) params.append('username', data.username);
  if (data.introduce != null) params.append('introduce', data.introduce);

  const url = `https://waffle-instaclone.kro.kr/api/user/profile/edit?${params.toString()}`;

  const options: RequestInit = {
    method: 'PATCH',
    headers: new Headers({
      Authorization: `Bearer ${localStorage.getItem('access_token') as string}`,
      Accept: 'application/json',
    }),
  };

  if (data.profile_image != null) {
    const formData = new FormData();
    formData.append('profile_image', data.profile_image);
    options.body = formData;
  }

  const response = await fetch(url, options);

  if (!response.ok) {
    throw new Error(`Failed to update profile`);
  }

  return response.json() as Promise<UserProfile>;
};

================
File: api/search.ts
================
import type { UserProfile } from '../types/user';

export const searchUsers = async (query: string): Promise<UserProfile[]> => {
  const response = await fetch(
    `https://waffle-instaclone.kro.kr/api/user/search?query=${encodeURIComponent(query)}`,
  );

  if (!response.ok) {
    throw new Error('Failed to search users');
  }

  return response.json() as Promise<UserProfile[]>;
};

================
File: components/feed/Stories.tsx
================
import { StoryList } from '../story/StoryList';

export function Stories() {
  return <StoryList />;
}

================
File: components/layout/MobileBar.tsx
================
import { Compass, Heart, Home, PlusSquare, User } from 'lucide-react';

import { NavItem } from './NavItem';

const MobileBar = () => {
  return (
    <nav className="flex md:hidden justify-around py-2 bg-white border-t">
      <NavItem icon={<Home />} to="/" mobile />
      <NavItem icon={<Compass />} to="/explore" mobile />
      <NavItem icon={<PlusSquare />} mobile />
      <NavItem icon={<Heart />} mobile />
      <NavItem icon={<User />} to="/username" mobile />
    </nav>
  );
};

export default MobileBar;

================
File: components/layout/MobileHeader.tsx
================
import { Heart, MessageCircle } from 'lucide-react';

const MobileHeader = () => {
  return (
    <div className="md:hidden flex justify-between items-center mb-4">
      <img src="/instagram-logo.png" alt="Instagram" className="w-24" />
      <div className="flex space-x-4">
        <Heart className="w-6 h-6" />
        <MessageCircle className="w-6 h-6" />
      </div>
    </div>
  );
};

export default MobileHeader;

================
File: components/layout/NavItem.tsx
================
import { type ReactNode } from 'react';
import { Link } from 'react-router-dom';

interface NavItemProps {
  icon: ReactNode;
  label?: string;
  active?: boolean;
  to?: string;
  onClick?: () => void;
  mobile?: boolean;
}

export const NavItem = ({
  icon,
  label,
  active = false,
  to,
  onClick,
  mobile = false,
}: NavItemProps) => {
  const className = mobile
    ? 'flex items-center justify-center p-2'
    : `flex items-center p-2 rounded-md ${
        active ? 'font-bold' : 'text-gray-700 hover:bg-gray-100'
      }`;

  const content = (
    <>
      {icon}
      {!mobile && label != null && (
        <span className="ml-4 hidden md:inline">{label}</span>
      )}
    </>
  );

  if (to != null) {
    return (
      <Link to={to} className={className}>
        {content}
      </Link>
    );
  }

  return (
    <button onClick={onClick} className={className}>
      {content}
    </button>
  );
};

================
File: components/layout/SideBar.tsx
================
import {
  Compass,
  Heart,
  Home,
  Menu,
  PlusSquare,
  Search,
  User,
} from 'lucide-react';
import { useContext, useEffect, useState } from 'react';
import { Link, useLocation } from 'react-router-dom';

import { LoginContext } from '../../App';
import { NavItem } from './NavItem';

interface SideBarProps {
  onSearchClick: () => void;
}

const SideBar = ({ onSearchClick }: SideBarProps) => {
  const [isMenuOpen, setIsMenuOpen] = useState(false);
  const [activeItem, setActiveItem] = useState('home');
  const [, setIsCreateModalOpen] = useState(false);
  const location = useLocation();

  const context = useContext(LoginContext);

  if (context === null) {
    throw new Error('LoginContext is not provided');
  }

  useEffect(() => {
    const path = location.pathname;
    if (path === '/') {
      setActiveItem('home');
    } else if (path === '/explore') {
      setActiveItem('explore');
    } else if (path === `/${String(context.myProfile?.username)}`) {
      setActiveItem('profile');
    } else {
      setActiveItem('');
    }
  }, [location.pathname, context.myProfile, context.myProfile?.username]);

  const handleCreateClick = (itemName: string) => {
    setActiveItem(itemName);
    setIsCreateModalOpen(true);
  };

  return (
    <div className="hidden md:flex md:flex-col h-full px-4 py-8">
      <div className="mb-8">
        <img
          src="https://a.slack-edge.com/production-standard-emoji-assets/14.0/apple-small/1f9c7@2x.png"
          alt="Logo"
          className="w-16"
        />
      </div>

      <div className="flex flex-col flex-1 space-y-2">
        <Link to="/">
          <NavItem
            icon={<Home />}
            label="Home"
            active={activeItem === 'home'}
          />
        </Link>
        <NavItem
          icon={<Search />}
          label="Search"
          active={activeItem === 'search'}
          onClick={() => {
            onSearchClick();
          }}
        />
        <Link to="/explore">
          <NavItem
            icon={<Compass />}
            label="Explore"
            active={activeItem === 'explore'}
          />
        </Link>
        <NavItem
          icon={<Heart />}
          label="Notifications"
          active={activeItem === 'notifications'}
        />
        <NavItem
          icon={<PlusSquare />}
          label="Create"
          active={activeItem === 'create'}
          onClick={() => {
            handleCreateClick('create');
          }}
        />
        <Link to={`/${String(context.myProfile?.username)}`}>
          <NavItem
            icon={<User />}
            label="Profile"
            active={activeItem === 'profile'}
          />
        </Link>
      </div>

      <div className="relative mt-auto">
        <NavItem
          icon={<Menu />}
          label="More"
          onClick={() => {
            setIsMenuOpen(!isMenuOpen);
          }}
        />
        {isMenuOpen && (
          <div className="absolute bottom-full left-0 mb-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5">
            <div className="py-1">
              <button
                className="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100 w-full text-left"
                onClick={() => {
                  context.handleIsLoggedIn(false, context.myProfile);
                  setIsMenuOpen(false);
                }}
              >
                Log Out
              </button>
            </div>
          </div>
        )}
      </div>
    </div>
  );
};

export default SideBar;

================
File: components/modals/SearchModal.tsx
================
import { Search, X } from 'lucide-react';
import { useEffect, useRef, useState } from 'react';
import { useNavigate } from 'react-router-dom';

import { searchUsers } from '../../api/search';
import type { UserProfile } from '../../types/user';

interface SearchModalProps {
  isOpen: boolean;
  onClose: () => void;
}

const SearchModal = ({ isOpen, onClose }: SearchModalProps) => {
  const navigate = useNavigate();
  const [searchTerm, setSearchTerm] = useState('');
  const [searchResults, setSearchResults] = useState<UserProfile[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const modalRef = useRef<HTMLDivElement>(null);

  useEffect(() => {
    const handleClickOutside = (event: MouseEvent) => {
      if (
        modalRef.current != null &&
        !modalRef.current.contains(event.target as Node)
      ) {
        onClose();
      }
    };

    if (isOpen) {
      document.addEventListener('mousedown', handleClickOutside);
      document.body.style.overflow = 'hidden';
    }

    return () => {
      document.removeEventListener('mousedown', handleClickOutside);
      document.body.style.overflow = 'unset';
    };
  }, [isOpen, onClose]);

  useEffect(() => {
    const searchDebounced = setTimeout(() => {
      if (searchTerm.length > 0) {
        setIsLoading(true);
        setError(null);
        void (async () => {
          try {
            const results = await searchUsers(searchTerm);
            if (Array.isArray(results)) {
              setSearchResults(results);
            } else {
              setSearchResults([]);
            }
          } catch (err) {
            setError(
              err instanceof Error
                ? err.message
                : 'An error occurred while searching',
            );
            setSearchResults([]);
          } finally {
            setIsLoading(false);
          }
        })();
      } else {
        setSearchResults([]);
      }
    }, 300);

    return () => {
      clearTimeout(searchDebounced);
    };
  }, [searchTerm]);

  const handleUserClick = (username: string) => {
    onClose();
    void navigate(`/${username}`);
  };

  if (!isOpen) return null;

  return (
    <div className="fixed inset-0 bg-black bg-opacity-50 z-50">
      <div
        ref={modalRef}
        className="fixed left-0 top-0 h-full w-[397px] bg-white shadow-lg animate-slide-in"
      >
        <div className="p-6">
          <div className="flex justify-between items-center mb-6">
            <h2 className="text-2xl font-bold">Search</h2>
            <button
              onClick={onClose}
              className="hover:bg-gray-100 p-1 rounded-full transition-colors"
            >
              <X size={24} />
            </button>
          </div>

          <div className="relative">
            <div className="absolute inset-y-0 left-3 flex items-center pointer-events-none">
              <Search size={20} className="text-gray-400" />
            </div>
            <input
              type="text"
              value={searchTerm}
              onChange={(e) => {
                setSearchTerm(e.target.value);
              }}
              placeholder="Search"
              className="w-full pl-10 pr-4 py-2 bg-gray-100 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
              autoFocus
            />
          </div>

          <div
            className="mt-6 overflow-y-auto"
            style={{ maxHeight: 'calc(100vh - 200px)' }}
          >
            {isLoading ? (
              <div className="text-center py-8">
                <p className="text-gray-600">Searching...</p>
              </div>
            ) : error != null ? (
              <div className="text-center py-8">
                <p className="text-red-500">{error}</p>
              </div>
            ) : searchTerm.length > 0 ? (
              searchResults.length > 0 ? (
                <div className="space-y-2">
                  {searchResults.map((user) => (
                    <div
                      key={user?.user_id}
                      onClick={() => {
                        handleUserClick(user?.username as string);
                      }}
                      className="flex items-center space-x-3 p-3 hover:bg-gray-50 rounded-lg cursor-pointer transition-colors"
                    >
                      <img
                        src={`https://waffle-instaclone.kro.kr/${user?.profile_image as string}`}
                        alt={user?.username}
                        className="w-12 h-12 rounded-full object-cover"
                      />
                      <div className="flex-1">
                        <p className="font-medium">{user?.username}</p>
                        <p className="text-sm text-gray-500">
                          {user?.full_name}
                        </p>
                      </div>
                    </div>
                  ))}
                </div>
              ) : (
                <div className="text-center py-8">
                  <p className="text-gray-500">No results found</p>
                </div>
              )
            ) : (
              <div className="text-center py-8">
                <p className="text-gray-400">Recent searches</p>
                <p className="mt-2 text-sm text-gray-400">No recent searches</p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
};

export default SearchModal;

================
File: components/shared/default-profile.svg
================
<svg viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
  <rect width="100" height="100" fill="#F3F4F6"/>
  <circle cx="50" cy="40" r="15" fill="#D1D5DB"/>
  <path d="M20 85 C20 65 80 65 80 85" fill="#D1D5DB"/>
</svg>

================
File: components/story/Editor/ImageProcessor.tsx
================
import { useEffect, useRef,useState } from 'react';

type Color = {
  r: number;
  g: number;
  b: number;
};

const ImageProcessor = ({ file, onProcessed }: { file: File | null, onProcessed: (blob: Blob) => void }) => {
  const [processedImage, setProcessedImage] = useState<string | null>(null);
	const [hasProcessed, setHasProcessed] = useState(false);
  const canvasRef = useRef(null);
  
  const TARGET_WIDTH = 1080;
  const TARGET_HEIGHT = 1920;
  const TARGET_RATIO = TARGET_HEIGHT / TARGET_WIDTH;

  const extractColors = (ctx: CanvasRenderingContext2D | null, width: number, height: number): [Color, Color] => {
    if (ctx == null) return [{ r: 0, g: 0, b: 0 }, { r: 0, g: 0, b: 0 }];
    const imageData = ctx.getImageData(0, 0, width, height).data;
    const colors: Color[] = [];
    
    // Sample pixels at regular intervals
    const sampleSize = Math.floor(imageData.length / 1000);
    for (let i = 0; i < imageData.length; i += sampleSize * 4) {
      const r = imageData[i] ?? 0;
      const g = imageData[i + 1] ?? 0;
      const b = imageData[i + 2] ?? 0;
      colors.push({ r, g, b });
    }

    // Get average color for muted background
    const avg: Color = colors.reduce((acc, color) => ({
			r: acc.r + color.r / colors.length,
			g: acc.g + color.g / colors.length,
			b: acc.b + color.b / colors.length
		}), { r: 0, g: 0, b: 0 });

    // Create slightly varied second color for gradient
    const secondColor: Color = {
      r: Math.min(255, avg.r * 0.8),
      g: Math.min(255, avg.g * 0.8),
      b: Math.min(255, avg.b * 0.8)
    };

    return [avg, secondColor];
  };

  useEffect(() => {
		const processImage = async (imageFile: Blob | MediaSource) => {
			if (hasProcessed) return;
			const img = new Image();
			img.src = URL.createObjectURL(imageFile);
			
			await new Promise((resolve) => {
				img.onload = resolve;
			});
	
			const canvas = canvasRef.current as HTMLCanvasElement | null;
			if (canvas == null) return;
			const ctx = canvas.getContext('2d');
			if (ctx == null) return;
	
			// Set canvas to target dimensions
			canvas.width = TARGET_WIDTH;
			canvas.height = TARGET_HEIGHT;
	
			// Extract colors from original image
			const tempCanvas = document.createElement('canvas');
			const tempCtx = tempCanvas.getContext('2d');
			if (tempCtx == null) return;
			tempCanvas.width = img.width;
			tempCanvas.height = img.height;
			tempCtx.drawImage(img, 0, 0);
			const [color1, color2] = extractColors(tempCtx, img.width, img.height);
	
			// Create gradient background
			const gradient = ctx.createLinearGradient(0, 0, 0, TARGET_HEIGHT);
			gradient.addColorStop(0, `rgba(${color1.r}, ${color1.g}, ${color1.b}, 0.8)`);
			gradient.addColorStop(1, `rgba(${color2.r}, ${color2.g}, ${color2.b}, 0.8)`);
			ctx.fillStyle = gradient;
			ctx.fillRect(0, 0, TARGET_WIDTH, TARGET_HEIGHT);
	
			// Calculate dimensions to maintain aspect ratio
			let drawWidth = TARGET_WIDTH;
			let drawHeight = TARGET_HEIGHT;
			const imageRatio = img.height / img.width;
	
			if (imageRatio > TARGET_RATIO) {
				drawWidth = TARGET_HEIGHT / imageRatio;
				drawHeight = TARGET_HEIGHT;
			} else {
				drawWidth = TARGET_WIDTH;
				drawHeight = TARGET_WIDTH * imageRatio;
			}
	
			// Center the image
			const x = (TARGET_WIDTH - drawWidth) / 2;
			const y = (TARGET_HEIGHT - drawHeight) / 2;
	
			// Draw the image centered
			ctx.drawImage(img, x, y, drawWidth, drawHeight);
	
			// Convert to blob and create URL
			const blob = await new Promise<Blob | null>(resolve => { canvas.toBlob(resolve, 'image/jpeg', 0.9); });
			if (blob == null) return;
			const processedUrl = URL.createObjectURL(blob);
			setProcessedImage(processedUrl);
			setHasProcessed(true);
			onProcessed(blob);
		};
    if (file != null && !hasProcessed) {
      void processImage(file);
    }
  }, [TARGET_RATIO, file, hasProcessed, onProcessed, processedImage]);

  return (
    <div className="w-full max-w-lg mx-auto">
      <canvas ref={canvasRef} className="hidden" />
      {(processedImage != null) && (
        <img 
          src={processedImage} 
          alt="Processed story"
          className="w-full h-auto rounded-lg shadow-lg"
        />
      )}
    </div>
  );
};

export default ImageProcessor;

================
File: components/story/Editor/StoryEditor.tsx
================
import { useCallback, useState } from 'react';
import { useLocation, useNavigate } from 'react-router-dom';

import ImageProcessor from './ImageProcessor';

const StoryEditor = () => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [error, setError] = useState<string | null>(null);
	const [isUploaded, setIsUploaded] = useState(false);
	const [processedBlob, setProcessedBlob] = useState<Blob | null>(null);
  const navigate = useNavigate();
  const location = useLocation();
  const state = location.state as { file: File };

  const handleProcessed = useCallback((blob: Blob) => {
		setProcessedBlob(blob);
	}, []);

	const handleShare = async () => {
    if (isProcessing || isUploaded || (processedBlob == null)) return;
    
    setIsProcessing(true);
    setError(null);

    try {
      const formData = new FormData();
      formData.append('files', processedBlob, 'story.jpg');

      const response = await fetch('https://waffle-instaclone.kro.kr/api/story/', {
        method: 'POST',
        headers: {
          Authorization: `Bearer ${localStorage.getItem('access_token') ?? ''}`,
        },
        body: formData,
      });

      if (!response.ok) {
        throw new Error('Failed to upload story');
      }

      setIsUploaded(true);
      void navigate('/', { replace: true });
    } catch (err) {
      setError(err instanceof Error ? err.message : 'An unknown error occurred');
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <div className="min-h-screen bg-gray-100 p-4">
      <div className="max-w-lg mx-auto">
        <h1 className="text-2xl font-bold mb-4">Edit Story</h1>
        
        <ImageProcessor 
          file={state.file} 
          onProcessed={handleProcessed}
        />

        {isProcessing && (
          <div className="mt-4 text-center text-gray-600">
            Processing and uploading your story...
          </div>
        )}

        {(error != null) && (
          <div className="mt-4 text-center text-red-500">
            {error}
          </div>
        )}

        <div className="mt-4 flex justify-end space-x-2">
          <button
            onClick={() => void navigate('/')}
            className="px-4 py-2 bg-gray-200 rounded-lg hover:bg-gray-300 transition-colors"
          >
            Cancel
          </button>
          <button
            onClick={() => void handleShare()}
            disabled={isProcessing || isUploaded || (processedBlob == null)}
            className="px-4 py-2 bg-blue-500 text-white rounded-lg hover:bg-blue-600 transition-colors disabled:opacity-50 disabled:cursor-not-allowed"
          >
            Share Story
          </button>
        </div>
      </div>
    </div>
  );
};

export default StoryEditor;

================
File: components/story/StoryViewer/StoryControls.tsx
================
import { ChevronLeft, ChevronRight, Trash2, X } from 'lucide-react';

interface StoryControlsProps {
  onNext: () => void;
  onPrevious: () => void;
  onClose: () => void;
  onDelete?: () => void;
  canGoNext: boolean;
  canGoPrevious: boolean;
  isOwner: boolean;
}

export default function StoryControls({
  onNext,
  onPrevious,
  onClose,
  onDelete,
  canGoNext,
  canGoPrevious,
  isOwner,
}: StoryControlsProps) {
  return (
    <div className="absolute inset-0 pointer-events-none">
      <div className="relative w-full h-full">
        <button
          onClick={onPrevious}
          className={`absolute left-4 top-1/2 -translate-y-1/2 p-2 rounded-full bg-black/50 pointer-events-auto transition-opacity
            ${canGoPrevious ? 'opacity-75 hover:opacity-100' : 'opacity-30 cursor-not-allowed'}`}
          disabled={!canGoPrevious}
          type="button"
          aria-label="Previous story"
        >
          <ChevronLeft className="w-6 h-6 text-white" />
        </button>

        <button
          onClick={onNext}
          className={`absolute right-4 top-1/2 -translate-y-1/2 p-2 rounded-full bg-black/50 pointer-events-auto transition-opacity
            ${canGoNext ? 'opacity-75 hover:opacity-100' : 'opacity-30 cursor-not-allowed'}`}
          disabled={!canGoNext}
          type="button"
          aria-label="Next story"
        >
          <ChevronRight className="w-6 h-6 text-white" />
        </button>

        <button
          onClick={onClose}
          className="absolute top-4 right-4 z-10 p-2 rounded-full bg-black/50 pointer-events-auto opacity-75 hover:opacity-100 transition-opacity"
          type="button"
          aria-label="Close story"
        >
          <X className="w-6 h-6 text-white" />
        </button>

        {isOwner && (onDelete != null) && (
          <button
            onClick={onDelete}
            className="absolute bottom-4 right-4 z-10 p-2 rounded-full bg-red-500 pointer-events-auto opacity-75 hover:opacity-100 transition-opacity"
            type="button"
            aria-label="Delete story"
          >
            <Trash2 className="w-6 h-6 text-white" />
          </button>
        )}
      </div>
    </div>
  );
}

================
File: components/story/StoryViewer/StoryProgress.tsx
================
interface StoryProgressProps {
  duration: number;
  currentTime: number;
}

export function StoryProgress({ duration, currentTime }: StoryProgressProps) {
  const progress = (currentTime / duration) * 100;

  return (
    <div className="h-1 bg-gray-600/30 rounded">
      <div
        className="h-full bg-white/90 rounded transition-all duration-100"
        style={{ width: `${progress}%` }}
      />
    </div>
  );
}

================
File: components/story/StoryViewer/StoryUserInfo.tsx
================
const formatTimeAgo = (dateString: string): string => {
  const date = new Date(dateString);
  const now = new Date();
  const diffInSeconds = Math.floor((now.getTime() - date.getTime()) / 1000);
  
  if (diffInSeconds < 60) {
    return 'just now';
  } else if (diffInSeconds < 3600) {
    const minutes = Math.floor(diffInSeconds / 60);
    return `${minutes}m ago`;
  } else if (diffInSeconds < 86400) {
    const hours = Math.floor(diffInSeconds / 3600);
    return `${hours}h ago`;
  } else {
    const days = Math.floor(diffInSeconds / 86400);
    return `${days}d ago`;
  }
};

interface StoryUserInfoProps {
  username: string;
  profileImage?: string;
  creationDate: string;
}

const StoryUserInfo = ({ username, profileImage, creationDate }: StoryUserInfoProps) => {
  return (
    <div className="absolute top-2 left-0 right-0 z-20">
      <div className="flex items-center space-x-3 px-4 py-2">
        <div className="w-8 h-8 rounded-full overflow-hidden bg-gray-300">
          <img
            src={profileImage}
            alt={username}
            className="w-full h-full object-cover"
            onError={(e) => {
							const img = e.target as HTMLImageElement;
							img.src = '/default-profile.svg';
						}}
          />
        </div>
        <div className="flex items-center space-x-2">
          <span className="text-white font-semibold text-sm">{username}</span>
          <span className="text-gray-300 text-xs">
            {formatTimeAgo(creationDate)}
          </span>
        </div>
      </div>
    </div>
  );
};

export default StoryUserInfo;

================
File: components/story/StoryViewer/StoryViewer.tsx
================
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';

import StoryControls from './StoryControls';
import { StoryProgress } from './StoryProgress';
import StoryUserInfo from './StoryUserInfo';

interface StoryViewerProps {
  stories: Array<{
    story_id: number;
    file_url: string[];
    creation_date: string;
    user_id: number;
  }>;
  username: string;
  profileImage?: string;
  onClose: () => void;
  onDelete?: (storyId: number) => Promise<void>;
  isOwner?: boolean;
  initialIndex: number;
}

const API_BASE_URL = 'https://waffle-instaclone.kro.kr';

export default function StoryViewer({
  stories,
  username,
  profileImage,
  onClose,
  onDelete,
  isOwner = false,
  initialIndex
}: StoryViewerProps) {
  const navigate = useNavigate();
  const [currentStoryIndex, setCurrentStoryIndex] = useState(initialIndex);
  const [progress, setProgress] = useState(0);
  const STORY_DURATION = 5000;

  useEffect(() => {
    const currentStory = stories[currentStoryIndex];
    if (currentStory != null) {
      localStorage.setItem(`story-${currentStory.story_id}-viewed`, new Date().toISOString());
    }
    const timer = setInterval(() => {
      setProgress((prev) => {
        if (prev >= STORY_DURATION) {
          if (currentStoryIndex < stories.length - 1) {
            setCurrentStoryIndex((index) => index + 1);
            return 0;
          } else {
            onClose();
            return prev;
          }
        }
        return prev + 100;
      });
    }, 100);

    return () => {
      clearInterval(timer);
    };
  }, [currentStoryIndex, stories, onClose]);

  const handleDelete = async (storyId: number) => {
    try {
      if (onDelete != null) {
        await onDelete(storyId);
        void navigate('/', { replace: true });
      }
    } catch (error) {
      console.error('Failed to delete story:', error);
    }
  };

  const handleNext = () => {
    if (currentStoryIndex < stories.length - 1) {
      setCurrentStoryIndex(prev => prev + 1);
      setProgress(0);
      const nextStory = stories[currentStoryIndex + 1];
      if (nextStory != null) {
        void navigate(`/stories/${username}/${nextStory.story_id}`, { replace: true });
      }
    } else {
      onClose();
    }
  };

  const handlePrevious = () => {
    if (currentStoryIndex > 0) {
      setCurrentStoryIndex((prev) => prev - 1);
      setProgress(0);
      const prevStory = stories[currentStoryIndex - 1];
      if (prevStory != null) {
        void navigate(`/stories/${username}/${prevStory.story_id}`, { replace: true });
      }
    }
  };

  const currentStory = stories[currentStoryIndex];
  if (currentStory == null) return null;

  // Convert relative URL to absolute URL
  const getFullImageUrl = (url: string) => {
    if (url.startsWith('http')) return url;
    return `${API_BASE_URL}/${url.replace(/^\/+/, '')}`;
  };

  return (
    <div className="fixed inset-0 bg-black z-50 flex items-center justify-center">
      <div className="relative w-full max-w-lg">
        <StoryProgress duration={STORY_DURATION} currentTime={progress} />
        <StoryUserInfo
          username={username}
          profileImage={profileImage}
          creationDate={currentStory.creation_date}
        />
        <div className="relative">
          <img
            src={
              currentStory.file_url[0] != null
                ? getFullImageUrl(currentStory.file_url[0])
                : ''
            }
            alt={`Story ${currentStory.story_id}`}
            className="w-full max-h-[90vh] object-contain"
            onError={(e) => {
              console.error('Image failed to load:', e);
              const img = e.target as HTMLImageElement;
              img.alt = 'Failed to load story image';
            }}
          />
          <div className="absolute inset-0">
            <StoryControls
              onNext={handleNext}
              onPrevious={handlePrevious}
              onClose={onClose}
              onDelete={onDelete != null ? () => void handleDelete(currentStory.story_id) : undefined}
              canGoNext={currentStoryIndex < stories.length - 1}
              canGoPrevious={currentStoryIndex > 0}
              isOwner={isOwner}
            />
          </div>
        </div>
      </div>
    </div>
  );
}

================
File: components/story/StoryCreator.tsx
================
import { CirclePlus } from 'lucide-react';
import { useCallback } from 'react';
import { useNavigate } from 'react-router-dom';

import { useStoryUpload } from '../../hooks/useStoryUpload';

export function StoryCreator() {
  const navigate = useNavigate();
  const { isUploading } = useStoryUpload();

  const handleFileUpload = useCallback((event: React.ChangeEvent<HTMLInputElement>) => {
    const files = event.target.files;
    if (files == null) return;

    if (files[0] != null) {
      void navigate('/stories/new', { 
        state: { file: files[0] }
      });
    }
  }, [navigate]);

  return (
    <div className="flex flex-col items-center">
      <label className="relative cursor-pointer">
        <div className="w-16 h-16 rounded-full bg-gray-100 flex items-center justify-center">
          <CirclePlus className="w-8 h-8 text-blue-500" />
        </div>
        <input
          type="file"
          accept="image/*"
          multiple
          onChange={handleFileUpload}
          className="hidden"
          disabled={isUploading}
        />
      </label>
      <p className="mt-1 text-xs">Create Story</p>
    </div>
  );
}

================
File: components/story/StoryItem.tsx
================
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';

import type { Story } from '../../types/story';

interface StoryItemProps {
  username: string;
  profileImage?: string;
  stories: Story[];
  onView: () => void;
}

export function StoryItem({
  username,
  profileImage,
  stories,
  onView
}: StoryItemProps) {
  const navigate = useNavigate();
  const [hasUnviewedStories, setHasUnviewedStories] = useState(false);
  useEffect(() => {
    const checkUnviewed = () => {
      const hasUnviewed = stories.some(story => {
        const viewedAt = localStorage.getItem(`story-${story.story_id}-viewed`);
        return viewedAt == null;
      });
      setHasUnviewedStories(hasUnviewed);
    };
    checkUnviewed();
  }, [stories]);
  const handleClick = () => {
    if (stories.length > 0) {
      // Find first unviewed story
      const firstUnviewed = stories.find(story => {
        const viewedAt = localStorage.getItem(`story-${story.story_id}-viewed`);
        return viewedAt == null;
      });

      // If all stories are viewed, show the first story
      const storyToShow = firstUnviewed ?? stories[0];
      
      if (storyToShow != null) {
        void navigate(`/stories/${username}/${storyToShow.story_id}`);
        onView();
      }
    }
  };

  return (
    <button
      onClick={handleClick}
      className="flex flex-col items-center"
      type="button"
    >
      <div
        className={`w-16 h-16 rounded-full p-0.5 ${
          stories.length > 0 && hasUnviewedStories
            ? 'bg-gradient-to-tr from-yellow-400 to-pink-600'
            : 'bg-gray-200'
        }`}
      >
        <div className="w-full h-full rounded-full bg-white p-0.5">
          <img
            src={profileImage ?? '../shared/default-profile.png'}
            alt={username}
            className="w-full h-full rounded-full object-cover"
          />
        </div>
      </div>
      <p className="mt-1 text-xs">{username}</p>
    </button>
  );
}

================
File: components/story/StoryList.tsx
================
import { useEffect, useState } from 'react';
import { useNavigate } from 'react-router-dom';

import type { Story } from '../../types/story';
import type { UserProfile } from '../../types/user';
import { StoryCreator } from './StoryCreator';
import { StoryItem } from './StoryItem';
import StoryViewer from './StoryViewer/StoryViewer';

const API_BASE = 'https://waffle-instaclone.kro.kr';

interface UserStoryData {
  stories: Story[];
  userProfile?: UserProfile;
}

export function StoryList() {
  const navigate = useNavigate();
  const [selectedUserId, setSelectedUserId] = useState<number | null>(null);
  const [viewingStories, setViewingStories] = useState<Story[]>([]);
  const [currentUserId, setCurrentUserId] = useState<number | null>(null);
  const [stories, setStories] = useState<Story[]>([]);
  const [userProfiles, setUserProfiles] = useState<Record<number, UserProfile>>({});
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch user profile for a specific user ID
  const fetchUserProfile = async (userId: number) => {
    try {
      const response = await fetch(`${API_BASE}/api/user/profile`, {
        headers: {
          Authorization: `Bearer ${localStorage.getItem('access_token') ?? ''}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to fetch user profile');
      }

      const userData = await response.json() as UserProfile;
      setUserProfiles(prev => ({
        ...prev,
        [userId]: userData
      }));
    } catch (err) {
      console.error(`Error fetching profile for user ${userId}:`, err);
    }
  };

  // Fetch current user profile
  useEffect(() => {
    // Fetch stories and associated user profiles
  const fetchStories = async (userId: number) => {
    try {
      const token = localStorage.getItem('access_token');
      if (token == null) return;

      const response = await fetch(`${API_BASE}/api/story/list/${userId}`, {
        headers: {
          Authorization: `Bearer ${token}`,
          Accept: 'application/json',
        },
      });

      if (!response.ok) {
        const errorData = await response.json() as { detail: string };
        throw new Error(errorData.detail || 'Failed to fetch stories');
      }

      const data = await response.json() as Story[];
      setStories(data);

      // Fetch user profiles for all unique user IDs in stories
      const uniqueUserIds = [...new Set(data.map(story => story.user_id))];
      await Promise.all(uniqueUserIds.map(uid => fetchUserProfile(uid)));

      setError(null);
    } catch (err) {
      console.error('Story fetch error:', err);
      setError(err instanceof Error ? err.message : 'Failed to fetch stories');
    }
  };
    const fetchUserInfo = async () => {
      try {
        setLoading(true);
        const token = localStorage.getItem('access_token');

        if (token == null) {
          localStorage.removeItem('isLoggedIn');
          void navigate('/');
          return;
        }

        const response = await fetch(`${API_BASE}/api/user/profile`, {
          headers: {
            Authorization: `Bearer ${token}`,
          },
        });

        if (!response.ok) {
          if (response.status === 401) {
            localStorage.removeItem('access_token');
            localStorage.removeItem('isLoggedIn');
            void navigate('/');
            return;
          }
          throw new Error('Failed to fetch user info');
        }

        const userData = await response.json() as UserProfile;
        if (userData?.user_id != null) {
          setCurrentUserId(userData.user_id);
          void fetchStories(userData.user_id);
        }
      } catch (err) {
        setError(err instanceof Error ? err.message : 'Unknown error occurred');
        console.error('Error fetching user info:', err);
      } finally {
        setLoading(false);
      }
    };

    void fetchUserInfo();
  }, [navigate]);

  const deleteStory = async (storyId: number) => {
    try {
      const response = await fetch(`${API_BASE}/api/story/${storyId}`, {
        method: 'DELETE',
        headers: {
          Authorization: `Bearer ${localStorage.getItem('access_token') ?? ''}`,
        },
      });

      if (!response.ok) {
        throw new Error('Failed to delete story');
      }

      setStories(stories.filter(story => story.story_id !== storyId));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete story');
      throw err;
    }
  };

  const handleViewStory = (userId: number, userStories: Story[]) => {
    setSelectedUserId(userId);
    setViewingStories(userStories);
  };

  const handleCloseViewer = () => {
    setSelectedUserId(null);
    setViewingStories([]);
  };

  if (error != null) {
    return <div className="text-red-500 p-4">{error}</div>;
  }

  const storyGroups = stories.reduce<Record<number, Story[]>>((acc, story) => {
    if (acc[story.user_id] == null) {
      acc[story.user_id] = [];
    }
    acc[story.user_id]?.push(story);
    return acc;
  }, {});

  return (
    <div className="flex space-x-4 overflow-x-auto pb-4 mb-8">
      <StoryCreator />
      
      {loading ? (
        <div className="animate-pulse flex space-x-4">
          <div className="w-16 h-16 bg-gray-200 rounded-full"></div>
          <div className="w-16 h-16 bg-gray-200 rounded-full"></div>
          <div className="w-16 h-16 bg-gray-200 rounded-full"></div>
        </div>
      ) : (
        <>
          {Object.entries(storyGroups).map(([userId, userStories]) => {
            const userProfile = userProfiles[Number(userId)];
            return (
              <StoryItem
                key={userId}
                username={userProfile?.username ?? 'Loading...'}
                profileImage={userProfile?.profile_image != null ? `${API_BASE}/${userProfile.profile_image}` : undefined}
                stories={userStories}
                onView={() => { handleViewStory(Number(userId), userStories); }}
              />
            );
          })}
        </>
      )}

      {viewingStories.length > 0 && (
        <StoryViewer
          stories={viewingStories}
          username={userProfiles[selectedUserId ?? 0]?.username ?? ''}
          onClose={handleCloseViewer}
          onDelete={selectedUserId === currentUserId ? deleteStory : undefined}
          isOwner={selectedUserId === currentUserId}
          initialIndex={0}
        />
      )}
    </div>
  );
}

================
File: hooks/useAuth.ts
================
import { useState } from 'react';

import type { UserProfile } from '../types/user';

export function useAuth() {
  const [isLoggedIn, setIsLoggedIn] = useState(() => {
    const saved = localStorage.getItem('isLoggedIn');
    return saved === 'true';
  });

  const [myProfile, setMyProfile] = useState<UserProfile | null>(() => {
    const saved = localStorage.getItem('userProfile');
    return saved != null ? (JSON.parse(saved) as UserProfile) : null;
  });

  const handleIsLoggedIn = (value: boolean, user: UserProfile) => {
    setIsLoggedIn(value);
    setMyProfile(user);
    localStorage.setItem('isLoggedIn', String(value));
    localStorage.setItem('userProfile', JSON.stringify(user));
  };

  return { isLoggedIn, myProfile, handleIsLoggedIn, setMyProfile };
}

================
File: hooks/useSearch.ts
================
import { useContext } from 'react';

import { SearchContext } from '../App';
import type { SearchContextType } from '../types/search';

export const useSearch = (): SearchContextType => {
  const context = useContext(SearchContext);
  if (context === null) {
    throw new Error('useSearch must be used within a SearchProvider');
  }
  return context;
};

================
File: hooks/useStories.ts
================
import { useEffect, useState } from 'react';

import type { Story } from '../types/story';

export function useStories(userId: number | null) {
  const [stories, setStories] = useState<Story[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchStories = async () => {
      if (userId == null) {
        setLoading(false);
        return;
      }

      try {
        setLoading(true);
        const token = localStorage.getItem('access_token');
        if (token == null) {
          throw new Error('No access token found');
        }

        const response = await fetch(
          `https://waffle-instaclone.kro.kr/api/story/list/${userId}`,
          {
            headers: {
              Authorization: `Bearer ${token}`,
              Accept: 'application/json',
            },
          },
        );

        if (!response.ok) {
          const errorText = await response.text();
          throw new Error(
            `Server responded with ${response.status}: ${errorText}`,
          );
        }

        const data = (await response.json()) as Story[];
        setStories(data);
      } catch (err) {
        console.error('Story fetch error:', err);
        setError(
          err instanceof Error ? err.message : 'Failed to fetch stories',
        );
      } finally {
        setLoading(false);
      }
    };

    void fetchStories();
  }, [userId]);

  const deleteStory = async (storyId: number) => {
    if (userId == null) return;

    try {
      const response = await fetch(
        `https://waffle-instaclone.kro.kr/api/story/${storyId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${localStorage.getItem('access_token') ?? ''}`,
          },
        },
      );

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`Failed to delete story: ${errorText}`);
      }

      setStories(stories.filter((story) => story.story_id !== storyId));
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to delete story');
      throw err;
    }
  };

  return { stories, loading, error, deleteStory };
}

================
File: hooks/useStoryUpload.ts
================
import { useState } from 'react';
import { useNavigate } from 'react-router-dom';

import type { Story } from '../types/story';

export function useStoryUpload() {
  const [isUploading, setIsUploading] = useState(false);
  const navigate = useNavigate();

  const uploadStory = async (files: FileList): Promise<Story> => {
    setIsUploading(true);
    const formData = new FormData();
    Array.from(files).forEach((file) => {
      formData.append('files', file);
    });

    try {
      const response = await fetch(
        'https://waffle-instaclone.kro.kr/api/story/',
        {
          method: 'POST',
          headers: {
            Authorization: `Bearer ${localStorage.getItem('access_token') ?? ''}`,
          },
          body: formData,
        },
      );

      if (!response.ok) throw new Error('Failed to upload story');
      const result = await response.json() as Story;
      void navigate('/', { replace: true });
      return result;
    } finally {
      setIsUploading(false);
    }
  };

  return { isUploading, uploadStory };
}

================
File: hooks/useUserInfo.ts
================
import { useEffect, useState } from 'react';

import { fetchUserProfile } from '../api/profile';
import type { UserProfile } from '../types/user';

export const useUserInfo = (username: string) => {
  const [userInfo, setUserInfo] = useState<UserProfile | null>(null);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<Error | null>(null);

  useEffect(() => {
    const loadUserInfo = async () => {
      try {
        setLoading(true);
        const data = await fetchUserProfile(username);
        setUserInfo(data);
      } catch (err) {
        setError(err instanceof Error ? err : new Error('Unknown error'));
      } finally {
        setLoading(false);
      }
    };

    void loadUserInfo();
  }, [username]);

  return { userInfo, loading, error };
};

================
File: pages/LoginPage.tsx
================
import React, { useState } from 'react';
import { Link } from 'react-router-dom';

import { signin } from '../api/auth';
import type { UserProfile } from '../types/user';

type LoginPageProps = {
  handleIsLoggedIn: (value: boolean, userData: UserProfile) => void;
};

const LoginPage = ({ handleIsLoggedIn }: LoginPageProps) => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const handleSubmit = async (e: React.FormEvent<HTMLFormElement>) => {
    e.preventDefault();
    if (username.length === 0 || password.length === 0) {
      setError('아이디와 비밀번호를 입력해주세요.');
      return;
    }
    try {
      const user = await signin(username, password);
      handleIsLoggedIn(true, user);
    } catch (err) {
      console.error('Login error:', err);
      setError(
        err instanceof Error ? err.message : '로그인 중 오류가 발생했습니다.',
      );
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 flex flex-col justify-center py-12 sm:px-6 lg:px-8">
      <div className="sm:mx-auto sm:w-full sm:max-w-md">
        <h1 className="text-center text-4xl font-extrabold text-red-500">
          Instagram
        </h1>
        <h2 className="mt-6 text-center text-3xl font-extrabold text-gray-900">
          로그인
        </h2>
      </div>

      <div className="mt-8 sm:mx-auto sm:w-full sm:max-w-md">
        <div className="bg-white py-8 px-4 shadow sm:rounded-lg sm:px-10">
          <form className="space-y-6" onSubmit={(e) => void handleSubmit(e)}>
            {error.length > 0 && (
              <div className="text-red-500 text-sm text-center">{error}</div>
            )}
            <div>
              <label
                htmlFor="username"
                className="block text-sm font-medium text-gray-700"
              >
                전화번호, 사용자 이름 또는 이메일
              </label>
              <div className="mt-1">
                <input
                  id="username"
                  name="username"
                  type="text"
                  autoComplete="username"
                  required
                  value={username}
                  onChange={(e) => {
                    setUsername(e.target.value);
                    setError('');
                  }}
                  className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                />
              </div>
            </div>

            <div>
              <label
                htmlFor="password"
                className="block text-sm font-medium text-gray-700"
              >
                비밀번호
              </label>
              <div className="mt-1">
                <input
                  id="password"
                  name="password"
                  type="password"
                  autoComplete="current-password"
                  required
                  value={password}
                  onChange={(e) => {
                    setPassword(e.target.value);
                    setError('');
                  }}
                  className="appearance-none block w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm placeholder-gray-400 focus:outline-none focus:ring-blue-500 focus:border-blue-500 sm:text-sm"
                />
              </div>
            </div>

            <div>
              <button
                type="submit"
                className="w-full flex justify-center py-2 px-4 border border-transparent rounded-md shadow-sm text-sm font-medium text-white bg-gradient-to-r from-purple-500 via-pink-500 to-pink-400 hover:from-purple-600 hover:via-pink-600 hover:to-pink-500 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-pink-500"
              >
                로그인
              </button>
            </div>
          </form>

          <div className="mt-6">
            <div className="text-sm text-center">
              <Link
                to="/register"
                className="font-medium text-blue-600 hover:text-blue-500"
              >
                계정이 없으신가요? 가입하기
              </Link>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default LoginPage;

================
File: pages/MainPage.tsx
================
import { Stories } from '../components/feed/Stories';
import MobileBar from '../components/layout/MobileBar';
import SideBar from '../components/layout/SideBar';
import SearchModal from '../components/modals/SearchModal';
import { useSearch } from '../hooks/useSearch';

const MainPage = () => {
  const { isSearchOpen, setIsSearchOpen } = useSearch();

  return (
    <div className="flex flex-col min-h-screen bg-gray-50">
      <SearchModal
        isOpen={isSearchOpen}
        onClose={() => {
          setIsSearchOpen(false);
        }}
      />
      
      <div className="flex-1 p-4 pb-16 md:pb-4 md:ml-64 overflow-y-auto">
        <div className="max-w-3xl mx-auto">
          <Stories />
        </div>
      </div>

      <div className="fixed bottom-0 left-0 right-0 md:left-0 md:top-0 md:right-auto md:w-64 bg-white border-t md:border-r md:border-t-0">
        <SideBar
          onSearchClick={() => {
            setIsSearchOpen(true);
          }}
        />
        <MobileBar />
      </div>
    </div>
  );
};

export default MainPage;

================
File: pages/StoryPage.tsx
================
import { useContext, useEffect, useState } from 'react';
import { useNavigate, useParams } from 'react-router-dom';

import { LoginContext } from '../App';
import StoryViewer from '../components/story/StoryViewer/StoryViewer';
import type { Story } from '../types/story';
import type { UserProfile } from '../types/user';

export default function StoryPage() {
  const { username, storyId } = useParams<{ username: string; storyId: string }>();
  const [stories, setStories] = useState<Story[]>([]);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const navigate = useNavigate();
  const context = useContext(LoginContext);

  useEffect(() => {
    const fetchStories = async () => {
      if (username == null) return;
      
      try {
        setLoading(true);
        // First fetch user info to get user_id
        const userResponse = await fetch(
          `https://waffle-instaclone.kro.kr/api/user/${username}`
        );
        if (!userResponse.ok) throw new Error('User not found');
        const userData = await userResponse.json() as UserProfile;
        if (userData?.user_id == null) throw new Error('Invalid user data');

        // Then fetch stories for that user
        const storiesResponse = await fetch(
          `https://waffle-instaclone.kro.kr/api/story/list/${userData.user_id}`,
          {
            headers: {
              Authorization: `Bearer ${localStorage.getItem('access_token') ?? ''}`,
            },
          }
        );
        if (!storiesResponse.ok) throw new Error('Failed to fetch stories');
        const storiesData = await storiesResponse.json() as Story[];
        
        setStories(storiesData);
        
        // Find the index of the requested story
        const index = storiesData.findIndex(
          story => story.story_id.toString() === storyId
        );
        if (index === -1) throw new Error('Story not found');
        setCurrentIndex(index);
      } catch (err) {
        setError(err instanceof Error ? err.message : 'An error occurred');
      } finally {
        setLoading(false);
      }
    };

    void fetchStories();
  }, [username, storyId]);

  if (loading) {
    return <div className="flex items-center justify-center h-screen">Loading...</div>;
  }

  if (error != null || stories.length === 0 || username == null) {
    return <div className="flex items-center justify-center h-screen">Story not found</div>;
  }

  const handleClose = () => {
    void navigate('/', { replace: true });
  };

  const handleDelete = async (storyToDeleteId: number) => {
    try {
      const response = await fetch(
        `https://waffle-instaclone.kro.kr/api/story/${storyToDeleteId}`,
        {
          method: 'DELETE',
          headers: {
            Authorization: `Bearer ${localStorage.getItem('access_token') ?? ''}`,
          },
        }
      );

      if (!response.ok) throw new Error('Failed to delete story');
      void navigate('/', { replace: true });
    } catch (err) {
      console.error('Failed to delete story:', err);
    }
  };

  const isOwner = context?.myProfile?.username === username;

  return (
    <StoryViewer
      stories={stories}
      username={username}
      onClose={handleClose}
      onDelete={isOwner ? handleDelete : undefined}
      isOwner={isOwner}
      initialIndex={currentIndex}
    />
  );
}

================
File: types/auth.ts
================
import type { UserProfile } from './user';

export type LoginContextType = {
  isLoggedIn: boolean;
  myProfile: UserProfile | null;
  handleIsLoggedIn: (value: boolean, userData: UserProfile) => void;
  setMyProfile: (profile: UserProfile) => void;
};

================
File: types/search.ts
================
export interface SearchContextType {
  isSearchOpen: boolean;
  setIsSearchOpen: (isOpen: boolean) => void;
}

================
File: types/story.ts
================
export interface Story {
  story_id: number;
  creation_date: string;
  expiration_date: string;
  user_id: number;
  file_url: string[];
}

================
File: types/user.ts
================
export type UserProfile = {
  user_id: number;
  username: string;
  full_name: string;
  email: string;
  phone_number: string;
  creation_date: string;
  profile_image: string;
  gender: string;
  birthday: string;
  introduce: string;
  website: string;
  follower_count: number;
  following_count: number;
  followers: number[];
  following: number[];
  post_count: number;
  post_ids: number[];
} | null;

================
File: App.tsx
================
import './index.css';

import { createContext, useState } from 'react';
import { Route, Routes } from 'react-router-dom';

import StoryEditor from './components/story/Editor/StoryEditor';
import { useAuth } from './hooks/useAuth';
import LoginPage from './pages/LoginPage';
import MainPage from './pages/MainPage';
import StoryPage from './pages/StoryPage';
import type { LoginContextType } from './types/auth';
import type { SearchContextType } from './types/search';

export const LoginContext = createContext<LoginContextType | null>(null);
export const SearchContext = createContext<SearchContextType | null>(null);

export const App = () => {
  const auth = useAuth();
  const [isSearchOpen, setIsSearchOpen] = useState(false);

  return (
    <LoginContext.Provider value={auth}>
      <SearchContext.Provider value={{ isSearchOpen, setIsSearchOpen }}>
        <Routes>
          <Route
            path="/"
            element={
              auth.isLoggedIn ? (
                <MainPage />
              ) : (
                <LoginPage handleIsLoggedIn={auth.handleIsLoggedIn} />
              )
            }
          />
          <Route 
            path="/stories/:username/:storyId" 
            element={auth.isLoggedIn ? <StoryPage /> : <LoginPage handleIsLoggedIn={auth.handleIsLoggedIn} />} 
          />
          <Route 
            path="/stories/new" 
            element={auth.isLoggedIn ? <StoryEditor /> : <LoginPage handleIsLoggedIn={auth.handleIsLoggedIn} />} 
          />
        </Routes>
      </SearchContext.Provider>
    </LoginContext.Provider>
  );
};

================
File: index.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

================
File: main.tsx
================
import { StrictMode } from 'react';
import { createRoot } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';

import { App } from './App';

const root = document.getElementById('root');

if (root === null) throw new Error('Root element not found');

createRoot(root).render(
  <StrictMode>
    <BrowserRouter>
      <App />
    </BrowserRouter>
  </StrictMode>,
);

================
File: vite-env.d.ts
================
/// <reference types="vite/client" />
